module.exports = {

"[project]/.next-internal/server/app/api/process-resume/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/node:events [external] (node:events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}}),
"[externals]/node:process [external] (node:process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}}),
"[externals]/node:util [external] (node:util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/node:stream [external] (node:stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}}),
"[externals]/fs/promises [external] (fs/promises, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs/promises", () => require("fs/promises"));

module.exports = mod;
}}),
"[project]/src/lib/gemini-service.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GeminiService": ()=>GeminiService
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/genai/dist/node/index.mjs [app-route] (ecmascript)");
;
class GeminiService {
    ai;
    constructor(){
        const apiKey = ("TURBOPACK compile-time value", "AIzaSyCrZ70VAsPH_-QF__jVSfZKBqxYCpqwpPg");
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        this.ai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleGenAI"]({
            apiKey
        });
    }
    // Simple sleep helper for backoff delays
    async sleep(milliseconds) {
        return new Promise((resolve)=>setTimeout(resolve, milliseconds));
    }
    // Robust generator with retries and fallback models for transient 5xx overloads
    async generateWithRetries(contents, models = [
        "gemini-2.5-flash",
        "gemini-1.5-flash"
    ], maxAttemptsPerModel = 3) {
        const isTransient = (error)=>{
            const anyErr = error;
            const status = anyErr?.status ?? anyErr?.code ?? anyErr?.error?.code;
            const message = (anyErr?.message || "").toString();
            // Treat 5xx or UNAVAILABLE as transient
            return status === 503 || status === 502 || status === 500 || message.includes("UNAVAILABLE") || message.includes("overloaded");
        };
        // Iterate models in order, retrying each on transient errors with exponential backoff
        for (const model of models){
            let attempt = 0;
            while(attempt < maxAttemptsPerModel){
                try {
                    return await this.ai.models.generateContent({
                        model,
                        contents
                    });
                } catch (error) {
                    attempt += 1;
                    if (!isTransient(error) || attempt >= maxAttemptsPerModel) {
                        // If not transient or attempts exhausted for this model, either try next model or rethrow
                        if (models.indexOf(model) === models.length - 1) {
                            throw error;
                        }
                        break; // move to next model
                    }
                    const backoffMs = Math.min(8000, 1000 * Math.pow(2, attempt - 1));
                    await this.sleep(backoffMs);
                }
            }
        }
        // Should not reach here; throw a generic error just in case
        throw new Error("AI service temporarily unavailable. Please try again later.");
    }
    async processResumeWithGemini(base64Data, fileType, fileName) {
        try {
            const today = new Date();
            const currentYear = today.getFullYear();
            const currentMonth = today.getMonth() + 1; // getMonth() returns 0-11
            const prompt = `
        FIRST: Determine if this document is actually a resume or CV. Look for:
        - Personal contact information (name, email, phone)
        - Work experience or employment history
        - Education background
        - Skills or qualifications
        - Professional summary or objective
        
        If this is NOT a resume/CV (e.g., it's a letter, invoice, article, etc.), return:
        {
          "document_type": "not_resume",
          "is_resume": false,
          "message": "This document does not appear to be a resume or CV. Please upload a resume document for analysis."
        }

        If this IS a resume/CV, analyze it and extract information in the following structured format:

        RESUME ANALYSIS:
        Extract all sections and provide ATS compatibility analysis.

        Return the data in JSON format with this structure:
        {
          "document_type": "resume",
          "is_resume": true,
          "header": {
            "name": "Full Name",
            "email": "email@example.com",
            "phone": "phone number",
            "location": "city, state",
            "linkedin": "check for linkedin url in the document and return it if present",
            "website": "check for personal website in the document and return it if present"
            "github": "check for github word and check whether it is a hyperlink and return url if it is a hyper link"
          },
          "sections": {
            "summary": "professional summary if present",
            "experience": [
              {
                "title": "Job Title",
                "company": "Company Name",
                "duration": "Duration (e.g., 2020-2022)",
                "description": "Job description",
                "achievements": ["achievement 1", "achievement 2"]
              }
            ],
            "education": [
              {
                "degree": "Degree Name",
                "institution": "Institution Name",
                "year": "Graduation Year",
                "gpa": "GPA if mentioned"
              }
            ],
            "skills": {
              "technical": ["skill1", "skill2"],
              "soft": ["soft skill1", "soft skill2"],
              "languages": ["language1", "language2"]
            },
            "certifications": [
              {
                "name": "Certification Name",
                "issuer": "Issuing Organization",
                "year": "Year obtained"
              }
            ]
          },
          "ats_analysis": {
            "score": 85,
            "issues": ["issue1", "issue2"],
            "recommendations": ["recommendation1", "recommendation2"],
            "keyword_matches": ["keyword1", "keyword2"],
            "missing_keywords": ["missing1", "missing2"]
          },
          "pro_suggestions": {
            "categories": [
              {
                "category": "Header Optimization",
                "priority": "High",
                "suggestions": [
                  "Move contact information to the very top of the resume",
                  "Use a professional email format (firstname.lastname@email.com)",
                  "Include a professional LinkedIn URL",
                  "Add a location that matches job requirements"
                ],
                "impact": "Improves ATS parsing by 25%"
              },
              {
                "category": "Experience Section",
                "priority": "High",
                "suggestions": [
                  "Use action verbs at the beginning of each bullet point",
                  "Include quantifiable achievements with numbers and percentages",
                  "Add industry-specific keywords naturally",
                  "Keep bullet points to 1-2 lines maximum"
                ],
                "impact": "Increases keyword matching by 40%"
              },
              {
                "category": "Skills Section",
                "priority": "Medium",
                "suggestions": [
                  "Create separate sections for technical and soft skills",
                  "Include proficiency levels (Beginner, Intermediate, Expert)",
                  "Add emerging technologies relevant to your field",
                  "Use industry-standard skill names"
                ],
                "impact": "Boosts skill recognition by 30%"
              },
              {
                "category": "Education & Certifications",
                "priority": "Medium",
                "suggestions": [
                  "Add graduation dates in MM/YYYY format",
                  "Include relevant certifications with expiration dates",
                  "List education in reverse chronological order",
                  "Add GPA if above 3.5"
                ],
                "impact": "Enhances qualification matching by 20%"
              },
              {
                "category": "Formatting & Structure",
                "priority": "High",
                "suggestions": [
                  "Use standard fonts (Arial, Calibri, Times New Roman)",
                  "Remove graphics, tables, and complex formatting",
                  "Use simple bullet points instead of custom symbols",
                  "Ensure consistent date formatting throughout"
                ],
                "impact": "Improves parsing accuracy by 35%"
              },
              {
                "category": "Keyword Optimization",
                "priority": "Critical",
                "suggestions": [
                  "Add missing industry keywords identified in analysis",
                  "Include job title variations",
                  "Add technology stack keywords",
                  "Include soft skills that match job requirements"
                ],
                "impact": "Increases ATS score by 15-25 points"
              }
            ],
            "summary": {
              "total_categories": 6,
              "total_suggestions": 24,
              "potential_score_increase": 25
            }
          }
        }

        IMPORTANT DATE VALIDATION RULES:
        - Current date is ${currentYear}-${currentMonth.toString().padStart(2, "0")}
        - "Present" or "Current" in dates is valid and should not be flagged as future
        - "Dec 2024 to present" is valid if we're in 2024
        - Only flag dates as future if they are clearly beyond the current date
        - Consider month abbreviations (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)

        ATS Analysis Guidelines:
        - Score: 0-100 based on ATS compatibility
        - Issues: List specific problems found, but be careful with date validation
        - Recommendations: Provide actionable improvement suggestions
        - Keywords: Extract relevant technical and industry keywords
        - Missing keywords: Suggest important keywords that could be added

        Pro Suggestions Guidelines:
        - Only provide if document is confirmed to be a resume/CV
        - Analyze the resume and provide specific, actionable suggestions for each category
        - Prioritize suggestions based on their impact on ATS compatibility
        - Focus on practical, implementable changes
        - Consider industry best practices and current ATS requirements
      `;
            const contents = [
                {
                    text: prompt
                },
                {
                    inlineData: {
                        mimeType: fileType === "application/pdf" ? "application/pdf" : "image/jpeg",
                        data: base64Data
                    }
                }
            ];
            const response = await this.generateWithRetries(contents, [
                "gemini-2.5-flash",
                "gemini-1.5-flash"
            ]);
            const responseText = response.text || "";
            let structuredData;
            try {
                // Try to parse JSON response
                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    structuredData = JSON.parse(jsonMatch[0]);
                } else {
                    throw new Error("No valid JSON found");
                }
            } catch (parseError) {
                // Fallback parsing with default pro suggestions
                structuredData = {
                    document_type: "resume",
                    is_resume: true,
                    header: {
                        name: "Extracted from document",
                        email: "",
                        phone: "",
                        location: ""
                    },
                    sections: {
                        experience: [],
                        education: [],
                        skills: {
                            technical: [],
                            soft: []
                        }
                    },
                    ats_analysis: {
                        score: 50,
                        issues: [
                            "Unable to parse structured data"
                        ],
                        recommendations: [
                            "Please check the document format"
                        ],
                        keyword_matches: [],
                        missing_keywords: []
                    },
                    pro_suggestions: {
                        categories: [
                            {
                                category: "Header Optimization",
                                priority: "High",
                                suggestions: [
                                    "Move contact information to the very top of the resume",
                                    "Use a professional email format",
                                    "Include a professional LinkedIn URL"
                                ],
                                impact: "Improves ATS parsing by 25%"
                            },
                            {
                                category: "Experience Section",
                                priority: "High",
                                suggestions: [
                                    "Use action verbs at the beginning of each bullet point",
                                    "Include quantifiable achievements",
                                    "Add industry-specific keywords naturally"
                                ],
                                impact: "Increases keyword matching by 40%"
                            }
                        ],
                        summary: {
                            total_categories: 2,
                            total_suggestions: 6,
                            potential_score_increase: 15
                        }
                    }
                };
            }
            return {
                success: true,
                data: structuredData,
                raw_text: responseText
            };
        } catch (error) {
            console.error("Error processing resume:", error);
            const anyErr = error;
            const status = anyErr?.status ?? anyErr?.code ?? anyErr?.error?.code;
            const friendly = status === 503 ? "The AI model is temporarily overloaded. We are retrying automatically; please try again in a moment if it persists." : anyErr?.message || "Unknown error occurred";
            return {
                success: false,
                error: friendly,
                raw_text: ""
            };
        }
    }
    async analyzeATSCompatibility(resumeData, jobKeywords = []) {
        try {
            const prompt = `
        You are an expert in Applicant Tracking Systems (ATS) and resume parsing.
        
        Your task is to analyze the given resume or CV data for ATS compatibility and provide a detailed evaluation.
        
        ====================
        Resume Data:
        ${JSON.stringify(resumeData, null, 2)}
        ====================
        
        Job Description Keywords (if provided): ${jobKeywords.join(", ")}
        
        Please perform a comprehensive analysis and return the following in JSON format under a key called "ats_analysis":
        
        1. **ATS Compatibility Score** (0-100): A numeric score based on how well the resume follows ATS best practices (formatting, structure, keyword usage, section naming, etc.).
        
        2. **Structural Completeness Check**:
           - Confirm presence of key sections:
             - Contact Information
             - Professional Summary or Objective
             - Work Experience
             - Skills
             - Education
             - Certifications (if available)
           - Note if any major section is missing.
        
        3. **Formatting Issues** (if any):
           - Usage of tables, columns, graphics, images, or non-standard fonts
           - File type concerns (PDF vs DOCX)
           - Unscannable content (e.g., in headers/footers)
        
        4. **Keyword Matching Analysis**:
           - Highlight which job-related keywords are present
           - Identify important missing keywords
           - Provide a match percentage based on provided job keywords
        
        5. **Detected Issues**:
           - List all potential ATS-blocking or ATS-confusing elements
        
        6. **Actionable Recommendations**:
           - Give specific and practical suggestions to improve ATS compatibility
           - Tailor suggestions based on detected formatting or content issues
           - Highlight enhancements in keyword optimization
        
        7. **Summary Verdict**:
           - Clear final judgment: "ATS-Friendly", "Moderately ATS-Compatible", or "Not ATS-Compatible"
           - Brief reasoning based on the overall analysis
        
        Make sure your analysis is accurate, concise, and informative. Return only the JSON with the "ats_analysis" section updated accordingly.
        `;
            const response = await this.generateWithRetries([
                {
                    text: prompt
                }
            ], [
                "gemini-2.5-flash",
                "gemini-1.5-flash"
            ]);
            console.log("Response: ", response);
            let enhancedData;
            try {
                const responseText = response.text || "";
                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    enhancedData = JSON.parse(jsonMatch[0]);
                } else {
                    // Fallback: enhance existing data
                    enhancedData = {
                        ...resumeData,
                        ats_analysis: {
                            ...resumeData.ats_analysis,
                            score: Math.min(100, (resumeData.ats_analysis?.score || 50) + 5),
                            recommendations: [
                                ...resumeData.ats_analysis?.recommendations || [],
                                "Consider tailoring keywords to specific job postings"
                            ],
                            issues: resumeData.ats_analysis?.issues || [],
                            keyword_matches: resumeData.ats_analysis?.keyword_matches || [],
                            missing_keywords: resumeData.ats_analysis?.missing_keywords || []
                        }
                    };
                }
            } catch (parseError) {
                enhancedData = resumeData;
            }
            return {
                success: true,
                data: enhancedData
            };
        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : "Unknown error occurred"
            };
        }
    }
}
}),
"[project]/src/app/api/process-resume/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$gemini$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/gemini-service.ts [app-route] (ecmascript)");
;
;
async function POST(request) {
    try {
        const formData = await request.formData();
        const file = formData.get("file");
        if (!file) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "No file provided"
            }, {
                status: 400
            });
        }
        // Validate file type
        const validTypes = [
            "application/pdf",
            "application/msword",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        ];
        if (!validTypes.includes(file.type)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Invalid file type. Please upload a PDF, DOC, or DOCX file."
            }, {
                status: 400
            });
        }
        // Validate file size (max 10MB)
        const maxSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxSize) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "File size too large. Please upload a file smaller than 10MB."
            }, {
                status: 400
            });
        }
        // Convert file to base64
        const arrayBuffer = await file.arrayBuffer();
        const buffer = Buffer.from(arrayBuffer);
        const base64Data = buffer.toString("base64");
        // Process with Gemini AI
        const geminiService = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$gemini$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GeminiService"]();
        const result = await geminiService.processResumeWithGemini(base64Data, file.type, file.name);
        if (!result.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: result.error || "Failed to process resume"
            }, {
                status: 500
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: result.data,
            message: "Resume processed successfully"
        });
    } catch (error) {
        console.error("Error processing resume:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Internal server error"
        }, {
            status: 500
        });
    }
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__c2e32e33._.js.map